"""Apply schema changes for GuildConfig and update foreign keys.

Revision ID: NEW_REVISION_ID # Replace with actual new revision ID
Revises: PREVIOUS_REVISION_ID # Replace with actual previous revision ID
Create Date: YYYY-MM-DD HH:MM:SS.MS

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID
import uuid

# revision identifiers, used by Alembic.
revision = 'NEW_REVISION_ID' # Replace with actual new revision ID
down_revision = 'PREVIOUS_REVISION_ID' # Replace with actual previous revision ID
branch_labels = None
depends_on = None

# Define table names and impacted columns for clarity
GUILD_CONFIGS_TABLE = 'guild_configs'
WORLD_STATES_TABLE = 'world_states'
RULES_CONFIG_TABLE = 'rules_config'

# List of other tables that have a foreign key to guild_configs.guild_id
# These might need their FK constraints recreated if they previously pointed to guild_configs.id (old PK)
# and if the database did not automatically retarget them when guild_configs.guild_id became PK.
# For this manual script, we assume they might need explicit recreation.
OTHER_TABLES_WITH_GUILD_FK = [
    'players', 'characters', 'locations', 'timers', 'events', 'parties',
    'generated_locations', 'item_templates', 'location_templates', 'npcs',
    'generated_npcs', 'generated_factions', 'global_npcs', 'items', 'inventory',
    'combats', 'game_logs', 'relationships', 'player_npc_memory', 'abilities',
    'skills', 'statuses', 'crafting_queues', 'item_properties', 'questlines',
    'quest_steps', 'mobile_groups', 'pending_conflicts', 'user_settings'
    # 'shops', 'currencies' also have guild_id but were not in the initial list, verify their FK target
]
# For 'shops' and 'currencies', based on the models.py, they seem to have a guild_id that is just a string,
# not explicitly a Foreign Key to guild_configs. If they DO have an FK to guild_configs, add them to the list.
# Assuming shops.guild_id and currencies.guild_id are NOT foreign keys to guild_configs for now as per models.py.

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # --- Stage 1: Prepare guild_configs table ---

    # To be safe, drop FKs from other tables that might be referencing the old 'guild_configs.id' (PK)
    # or columns that will be altered significantly (like guild_id becoming PK).
    # This is highly dependent on existing constraint names. Using generic names for illustration.
    # In a real scenario, inspect DB for actual constraint names.

    # Example for world_states (assuming its FK was named fk_world_states_guild_id)
    # op.drop_constraint('fk_world_states_guild_id', WORLD_STATES_TABLE, type_='foreignkey')
    # Example for rules_config (assuming its FK was named fk_rules_config_guild_id)
    # op.drop_constraint('fk_rules_config_guild_id', RULES_CONFIG_TABLE, type_='foreignkey')

    # For all other tables, if their FK to guild_configs was targeting the old 'id' column:
    # for table_name in OTHER_TABLES_WITH_GUILD_FK:
    #     try:
    #         op.drop_constraint(f'fk_{table_name}_guild_id', table_name, type_='foreignkey') # Placeholder name
    #     except Exception as e:
    #         print(f"Could not drop FK constraint for {table_name}, it might not exist or name is different: {e}")


    # Drop the old primary key constraint if it was on 'id' and named (e.g. 'pk_guild_configs')
    # op.drop_constraint('pk_guild_configs', GUILD_CONFIGS_TABLE, type_='primary')
    # Or, more directly if 'id' was the PK by default without a specific named constraint:
    # (This part is tricky without knowing the exact old PK constraint on 'id')
    # It's often safer to drop the column that holds the PK, and then set the new PK.
    # If 'id' is dropped, its PK status is implicitly dropped.

    op.drop_column(GUILD_CONFIGS_TABLE, 'id')

    # --- Stage 2: Modify guild_configs columns ---

    # Ensure guild_id is primary key
    # First, alter guild_id if it's not already suitable (e.g., nullable=False, though model should ensure this)
    op.alter_column(GUILD_CONFIGS_TABLE, 'guild_id',
                    existing_type=sa.String(),
                    nullable=False,
                    primary_key=True) # This might implicitly create the PK or require a separate op.create_primary_key

    # If alter_column with primary_key=True doesn't create the PK constraint, or if you need a named one:
    # op.create_primary_key('pk_guild_configs_new', GUILD_CONFIGS_TABLE, ['guild_id'])


    # Add new columns
    # master_channel_id was already in the model, but ensure it's in DB
    op.add_column(GUILD_CONFIGS_TABLE, sa.Column('master_channel_id', sa.String(), nullable=True))
    op.add_column(GUILD_CONFIGS_TABLE, sa.Column('notification_channel_id', sa.String(), nullable=True))

    # Rename system_notifications_channel_id to system_channel_id
    op.alter_column(GUILD_CONFIGS_TABLE, 'system_notifications_channel_id',
                    new_column_name='system_channel_id',
                    existing_type=sa.String(),
                    nullable=True)

    # --- Stage 3: Recreate Foreign Keys to point to the new guild_configs.guild_id PK ---

    # Recreate FK for world_states
    # First, attempt to drop an existing FK if it might conflict or be misconfigured
    try:
        op.drop_constraint('fk_world_states_guild_id_guild_configs', WORLD_STATES_TABLE, type_='foreignkey') # Old/existing name
    except Exception: # Catch if it doesn't exist, which is fine
        pass
    op.create_foreign_key(
        'fk_world_states_guild_id_guild_configs', # New or same constraint name
        WORLD_STATES_TABLE, GUILD_CONFIGS_TABLE,
        ['guild_id'], ['guild_id'],
        ondelete='CASCADE'
    )

    # Recreate FK for rules_config (and ensure ondelete='CASCADE')
    try:
        op.drop_constraint('fk_rules_config_guild_id_guild_configs', RULES_CONFIG_TABLE, type_='foreignkey') # Old/existing name
    except Exception:
        pass
    op.create_foreign_key(
        'fk_rules_config_guild_id_guild_configs', # New or same constraint name
        RULES_CONFIG_TABLE, GUILD_CONFIGS_TABLE,
        ['guild_id'], ['guild_id'],
        ondelete='CASCADE'
    )

    # Recreate FKs for all other relevant tables
    # This assumes their FK column is named 'guild_id' and should point to 'guild_configs.guild_id'
    # This is a simplified loop; actual constraint names might vary.
    # This step is crucial if these tables previously FK'd to the old 'guild_configs.id'
    for table_name in OTHER_TABLES_WITH_GUILD_FK:
        constraint_name = f'fk_{table_name}_guild_id_guild_configs'
        try:
            op.drop_constraint(constraint_name, table_name, type_='foreignkey')
        except Exception: # Catch if it doesn't exist
            pass
        op.create_foreign_key(
            constraint_name,
            table_name, GUILD_CONFIGS_TABLE,
            ['guild_id'], ['guild_id'], # Assumes FK column in other table is also 'guild_id'
            ondelete='CASCADE' # Assuming CASCADE for all these based on model patterns
        )
    # Note: The above loop for OTHER_TABLES_WITH_GUILD_FK is a general approach.
    # It's critical that these tables' FKs correctly target guild_configs.guild_id.
    # If Alembic's autogenerate (when used with `compare_type=True`) doesn't handle
    # retargeting existing FKs automatically when the referenced PK changes,
    # explicit drop/create of those FKs would be needed, requiring their actual names.
    # The models were updated to ForeignKey('guild_configs.guild_id'), so this should align.

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # --- Stage 1: Drop Foreign Keys pointing to guild_configs.guild_id (new PK) ---
    op.drop_constraint('fk_world_states_guild_id_guild_configs', WORLD_STATES_TABLE, type_='foreignkey')
    op.drop_constraint('fk_rules_config_guild_id_guild_configs', RULES_CONFIG_TABLE, type_='foreignkey')

    for table_name in OTHER_TABLES_WITH_GUILD_FK:
        try:
            op.drop_constraint(f'fk_{table_name}_guild_id_guild_configs', table_name, type_='foreignkey')
        except Exception as e:
            print(f"Could not drop FK constraint for {table_name} during downgrade: {e}")


    # --- Stage 2: Revert guild_configs table modifications ---

    # Drop primary key constraint on guild_id
    # op.drop_constraint('pk_guild_configs_new', GUILD_CONFIGS_TABLE, type_='primary') # If named PK was created
    # Or make guild_id non-primary if alter_column handled it:
    op.alter_column(GUILD_CONFIGS_TABLE, 'guild_id',
                    existing_type=sa.String(),
                    primary_key=False, # Remove PK status
                    nullable=False) # Should remain nullable=False and indexed as per original model

    # Add back the 'id' column as UUID primary key
    op.add_column(GUILD_CONFIGS_TABLE, sa.Column('id', UUID(as_uuid=True), nullable=False))
    # Explicitly set it as PK after adding. Default value needs to be handled by application or db default if possible.
    # For existing rows, this new id column would need values. This can be complex.
    # A common strategy is to make it nullable, populate, then make non-nullable. Or default to uuid.uuid4()
    # For simplicity in downgrade, assuming it can be added and then PK constraint applied.
    # Defaulting in SA: sa.Column('id', UUID(as_uuid=True), primary_key=True, server_default=sa.text("gen_random_uuid()")) for postgres

    # Making 'id' the primary key. This assumes 'id' column is now populated or has a default.
    op.create_primary_key('pk_guild_configs_oldid', GUILD_CONFIGS_TABLE, ['id'])


    # Rename system_channel_id back to system_notifications_channel_id
    op.alter_column(GUILD_CONFIGS_TABLE, 'system_channel_id',
                    new_column_name='system_notifications_channel_id',
                    existing_type=sa.String(),
                    nullable=True)

    # Drop added columns
    op.drop_column(GUILD_CONFIGS_TABLE, 'notification_channel_id')
    op.drop_column(GUILD_CONFIGS_TABLE, 'master_channel_id') # If it was truly new

    # --- Stage 3: Recreate Foreign Keys to point to the old guild_configs.id PK ---

    # Recreate FK for world_states to point to old 'id' PK
    op.create_foreign_key(
        'fk_world_states_guild_id_guild_configs_old',
        WORLD_STATES_TABLE, GUILD_CONFIGS_TABLE,
        ['guild_id'], ['id'], # guild_id in world_states now points to id in guild_configs
        ondelete='CASCADE'
    )

    # Recreate FK for rules_config to point to old 'id' PK (and remove ondelete='CASCADE' if it was added in this migration)
    op.create_foreign_key(
        'fk_rules_config_guild_id_guild_configs_old',
        RULES_CONFIG_TABLE, GUILD_CONFIGS_TABLE,
        ['guild_id'], ['id'], # guild_id in rules_config now points to id in guild_configs
        # ondelete=None # Or whatever the original ondelete status was. Assuming no cascade for downgrade to original state.
    )

    # Recreate FKs for all other relevant tables to point to 'guild_configs.id'
    for table_name in OTHER_TABLES_WITH_GUILD_FK:
        op.create_foreign_key(
            f'fk_{table_name}_guild_id_guild_configs_old',
            table_name, GUILD_CONFIGS_TABLE,
            ['guild_id'], ['id'],
            ondelete='CASCADE' # Assuming original was CASCADE
        )

    # ### end Alembic commands ###