# bot/api/routers/game_log.py
from fastapi import APIRouter, Depends, HTTPException, Path, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError
import uuid # For generating log entry IDs (already default in model)
import logging
from typing import List, Optional

from bot.api.dependencies import get_db_session
from bot.api.schemas.game_log_schemas import GameLogEntryCreate, GameLogEntryResponse
from bot.database.models import GameLog

logger = logging.getLogger(__name__)
router = APIRouter() # Prefix will be /api/v1/guilds/{guild_id}/ from main.py

@router.post("/log_event", response_model=GameLogEntryResponse, status_code=status.HTTP_201_CREATED, summary="Log a new game event")
async def create_game_log_entry(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    log_entry_data: GameLogEntryCreate = Depends(),
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Attempting to log event type '{log_entry_data.event_type}' in guild {guild_id}")

    # The GameLog model's id has a default=lambda: str(uuid.uuid4()), so no need to set it manually.
    # Timestamp is also auto-generated by server_default=func.now().
    db_log_entry = GameLog(
        guild_id=guild_id,
        **log_entry_data.dict(exclude_none=True) # exclude_none to handle optional fields not sent
    )
    db.add(db_log_entry)
    try:
        await db.commit()
        await db.refresh(db_log_entry)
    except Exception as e:
        await db.rollback()
        logger.error(f"Error logging event: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not log event.")
    return db_log_entry

@router.get("/events", response_model=List[GameLogEntryResponse], summary="List game events for the guild")
async def list_game_log_entries(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    event_type: Optional[str] = Query(None, description="Filter by event type"),
    player_id: Optional[str] = Query(None, description="Filter by involved player ID"),
    # Add other filters as needed, e.g., date range, involved_entity_type/id
    skip: int = Query(0, ge=0, description="Records to skip for pagination"),
    limit: int = Query(100, ge=1, le=500, description="Max records to return for pagination"),
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Listing game logs for guild {guild_id} with filters: event_type='{event_type}', player_id='{player_id}'")

    stmt = select(GameLog).where(GameLog.guild_id == guild_id)

    if event_type:
        stmt = stmt.where(GameLog.event_type == event_type)
    if player_id:
        # This assumes player_id is directly on GameLog or needs a JSON contains query if in involved_entities_ids
        # For simplicity, using the direct player_id field on GameLog for now.
        stmt = stmt.where(GameLog.player_id == player_id)
        # If filtering by involved_entities_ids:
        # from sqlalchemy.dialects.postgresql import JSONB
        # stmt = stmt.where(GameLog.involved_entities_ids.cast(JSONB).contains([{"type": "player", "id": player_id}]))

    stmt = stmt.order_by(GameLog.timestamp.desc()).offset(skip).limit(limit)

    result = await db.execute(stmt)
    log_entries = result.scalars().all()
    return log_entries
