# bot/api/routers/location.py
from fastapi import APIRouter, Depends, HTTPException, Path, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError
# import uuid # Not strictly needed here as model default handles ID generation
import logging
from typing import List, Optional

from bot.api.dependencies import get_db_session
from bot.api.schemas.location_schemas import LocationCreate, LocationUpdate, LocationResponse
from bot.database.models import Location

logger = logging.getLogger(__name__)
router = APIRouter() # Prefix will be /api/v1/guilds/{guild_id}/locations from main.py

@router.post("/", response_model=LocationResponse, status_code=status.HTTP_201_CREATED, summary="Create a new location for the guild")
async def create_location(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    location_data: LocationCreate, # Direct body parameter
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Attempting to create location '{location_data.name_i18n.get('en', 'Unknown Name')}' in guild {guild_id}")

    # ID is auto-generated by default in the Location model
    db_location = Location(
        guild_id=guild_id,
        **location_data.dict(exclude_none=True) # exclude_none for optional fields not set
    )
    db.add(db_location)
    try:
        await db.commit()
        await db.refresh(db_location)
    except IntegrityError as e:
        await db.rollback()
        # Could be due to unique constraint on static_name if one were added per guild
        logger.error(f"IntegrityError creating location: {e}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Could not create location due to data integrity issue: {e}")
    except Exception as e:
        await db.rollback()
        logger.error(f"Error creating location: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not create location.")
    return db_location

@router.get("/", response_model=List[LocationResponse], summary="List all locations for the guild")
async def list_locations(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    skip: int = Query(0, ge=0, description="Records to skip for pagination"),
    limit: int = Query(100, ge=1, le=200, description="Max records to return for pagination"),
    location_type_en: Optional[str] = Query(None, description="Filter by English location type (exact match on type_i18n.en)"), # Example filter
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Listing locations for guild {guild_id} with skip={skip}, limit={limit}")
    stmt = select(Location).where(Location.guild_id == guild_id)

    if location_type_en:
        # This is a basic filter and might need adjustment based on JSON query capabilities of the DB
        # For PostgreSQL, you can do: from sqlalchemy.dialects.postgresql import JSONB
        # stmt = stmt.where(Location.type_i18n.cast(JSONB)['en'].astext == location_type_en)
        # For now, a simpler approach might require fetching all and filtering in Python if complex JSON queries are not set up.
        # Or, assume a simpler structure or a dedicated queryable field if this is a common use case.
        # For this example, we'll omit the filter for direct DB query to keep it simple.
        # A real implementation would need robust filtering.
        logger.warning(f"Filtering by location_type_en ('{location_type_en}') is not yet implemented at the database query level.")
        pass


    stmt = stmt.order_by(Location.name_i18n).offset(skip).limit(limit) # Order by name (might need specific language key)
    result = await db.execute(stmt)
    locations = result.scalars().all()
    return locations

@router.get("/{location_id}", response_model=LocationResponse, summary="Get a specific location by ID")
async def get_location(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    location_id: str = Path(..., description="ID of the location to retrieve"),
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Fetching location {location_id} for guild {guild_id}")
    stmt = select(Location).where(Location.id == location_id, Location.guild_id == guild_id)
    result = await db.execute(stmt)
    db_location = result.scalars().first()
    if not db_location:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Location not found in this guild")
    return db_location

@router.put("/{location_id}", response_model=LocationResponse, summary="Update a location")
async def update_location(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    location_id: str = Path(..., description="ID of the location to update"),
    location_update_data: LocationUpdate, # Direct body parameter
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Updating location {location_id} in guild {guild_id}")
    stmt = select(Location).where(Location.id == location_id, Location.guild_id == guild_id)
    result = await db.execute(stmt)
    db_location = result.scalars().first()

    if not db_location:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Location not found in this guild")

    update_data = location_update_data.dict(exclude_unset=True) # Get only fields that were actually sent
    for key, value in update_data.items():
        setattr(db_location, key, value)

    db.add(db_location)
    try:
        await db.commit()
        await db.refresh(db_location)
    except Exception as e:
        await db.rollback()
        logger.error(f"Error updating location {location_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not update location.")
    return db_location

@router.delete("/{location_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Delete a location")
async def delete_location(
    guild_id: str = Path(..., description="Guild ID from path prefix"),
    location_id: str = Path(..., description="ID of the location to delete"),
    db: AsyncSession = Depends(get_db_session)
):
    logger.info(f"Attempting to delete location {location_id} in guild {guild_id}")
    stmt = select(Location).where(Location.id == location_id, Location.guild_id == guild_id)
    result = await db.execute(stmt)
    db_location = result.scalars().first()

    if not db_location:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Location not found in this guild")

    # Check for dependencies (e.g., players in this location) before deleting
    # from bot.database.models import Player # Example check
    # player_check_stmt = select(Player.id).where(Player.current_location_id == location_id, Player.guild_id == guild_id).limit(1)
    # if (await db.execute(player_check_stmt)).scalars().first():
    #     raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Cannot delete location: Players are currently in this location.")

    await db.delete(db_location)
    try:
        await db.commit()
    except IntegrityError as e: # Catch FK violations if other tables link to locations with RESTRICT
        await db.rollback()
        logger.error(f"IntegrityError deleting location {location_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Cannot delete location: It is referenced by other entities. Details: {e}")
    except Exception as e:
        await db.rollback()
        logger.error(f"Error deleting location {location_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not delete location.")
    return
