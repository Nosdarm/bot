"""restructure_rules_config_to_key_value

Revision ID: d7c14313c370
Revises: 611e4e433eac
Create Date: 2025-06-16 14:01:14.704368

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'd7c14313c370'
down_revision: Union[str, None] = '611e4e433eac' # Replace with the actual previous revision ID if known
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # Ensure uuid-ossp extension is available for uuid_generate_v4()
    op.execute('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";')
    # ### commands auto generated by Alembic - please adjust! ###

    # Drop the existing primary key constraint on guild_id if it exists
    # First, we need to know the name of the primary key constraint.
    # Assuming it's 'rules_config_pkey' by convention. This might need to be checked.
    # op.drop_constraint('rules_config_pkey', 'rules_config', type_='primary') # Disabling for now, PK change handled differently

    # Add the new 'id' column, which will become the primary key
    op.add_column('rules_config', sa.Column('id', sa.String(), nullable=False, server_default=sa.text('uuid_generate_v4()'))) # Using server_default for uuid

    # To make 'id' the primary key, we might need to recreate the table or use specific alter statements.
    # A simpler approach for now if 'guild_id' was the PK:
    # 1. Add 'id' with a unique constraint temporarily and nullable=False
    # 2. Populate 'id' with UUIDs for existing rows (if data migration was part of this)
    # 3. Drop old PK (on guild_id)
    # 4. Add new PK (on 'id')
    # However, given the model change, Alembic might handle PK replacement if the old PK is dropped and new one added.
    # For now, let's assume 'id' column added above will be made PK.
    # If 'guild_id' was PK, it needs to be altered. If it was not, its properties might remain.
    # The model had guild_id = Column(String, primary_key=True). So it was the PK.

    # We need to ensure guild_id is no longer primary key.
    # Altering column guild_id: it's no longer a PK, but it's indexed and part of a unique constraint.
    # If guild_id was the PK, its nullable status was False implicitly. Now it's explicitly False.
    op.alter_column('rules_config', 'guild_id',
               existing_type=sa.VARCHAR(),
               primary_key=False, # Explicitly state it's not PK anymore
               nullable=False)

    # Create primary key on the new 'id' column
    # This might fail if a PK (like the old one on guild_id) still exists.
    # It's often better to drop the old PK constraint by name first.
    # For this script, we are adding 'id' and then making it PK.
    # If 'rules_config_pkey' was on 'guild_id', it should be dropped.
    # Let's try to create the PK on 'id'. If guild_id was PK, this implies it's replaced.
    # If there was an existing PK, op.create_primary_key might require dropping the old one first.
    # A common pattern is to drop the old PK by name.
    op.drop_constraint('rules_config_pkey', 'rules_config', type_='primary') # Uncomment if needed and name is correct
    op.create_primary_key('rules_config_pkey', 'rules_config', ['id'])


    op.add_column('rules_config', sa.Column('key', sa.String(), nullable=False))
    op.add_column('rules_config', sa.Column('value', postgresql.JSONB(astext_type=sa.Text()), nullable=True))

    op.create_index('idx_rulesconfig_guild_key', 'rules_config', ['guild_id', 'key'], unique=False)
    # Index for guild_id alone (as per model)
    op.create_index(op.f('ix_rules_config_guild_id'), 'rules_config', ['guild_id'], unique=False)
    # Index for key alone (as per model)
    op.create_index(op.f('ix_rules_config_key'), 'rules_config', ['key'], unique=False)

    op.create_unique_constraint('uq_guild_rule_key', 'rules_config', ['guild_id', 'key'])

    op.drop_column('rules_config', 'config_data')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('rules_config', sa.Column('config_data', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True))

    op.drop_constraint('uq_guild_rule_key', 'rules_config', type_='unique')

    op.drop_index(op.f('ix_rules_config_key'), table_name='rules_config')
    op.drop_index(op.f('ix_rules_config_guild_id'), table_name='rules_config')
    op.drop_index('idx_rulesconfig_guild_key', table_name='rules_config')

    op.drop_column('rules_config', 'value')
    op.drop_column('rules_config', 'key')

    # Drop the new primary key constraint on 'id'
    op.drop_constraint('rules_config_pkey', 'rules_config', type_='primary')
    op.drop_column('rules_config', 'id')

    # Restore guild_id as primary key
    op.alter_column('rules_config', 'guild_id',
               existing_type=sa.VARCHAR(),
               primary_key=True,
               nullable=False) # PKs are implicitly not nullable
    # Attempt to drop the extension if it was created by this migration and no longer needed.
    op.execute('DROP EXTENSION IF EXISTS "uuid-ossp";')
    # ### end Alembic commands ###
