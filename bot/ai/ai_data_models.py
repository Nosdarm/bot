from pydantic import BaseModel, validator
from typing import List, Dict, Optional, Any
import json

class GeneratedQuestStep(BaseModel):
    """
    Pydantic model for a single quest step generated by AI.
    Corresponds to game.models.quest_step.QuestStep
    """
    title_i18n: Dict[str, str]
    description_i18n: Dict[str, str]
    required_mechanics_json: str  # JSON string for specific mechanics
    abstract_goal_json: str       # JSON string for abstract goals
    step_order: int
    consequences_json: str        # JSON string for step-specific consequences
    assignee_type: Optional[str] = None # e.g., 'player', 'party'
    assignee_id: Optional[str] = None   # player_id or party_id

    @validator('required_mechanics_json', 'abstract_goal_json', 'consequences_json', pre=True, allow_reuse=True)
    def ensure_valid_json_string(cls, value: Any) -> str:
        if isinstance(value, (dict, list)): # If AI provides actual dict/list
            try:
                return json.dumps(value)
            except (TypeError, OverflowError) as e:
                raise ValueError(f"Invalid object for JSON stringification: {e}")
        if not isinstance(value, str):
            raise ValueError("JSON field must be a string.")
        try:
            json.loads(value)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON string: {e}")
        return value

class GeneratedQuest(BaseModel):
    """
    Pydantic model for a complete quest structure generated by AI.
    Corresponds to game.models.quest.Quest
    """
    # Using name_i18n for consistency, AI might output as title_i18n.
    # The data loading mechanism should handle aliasing if needed.
    name_i18n: Dict[str, str]
    description_i18n: Dict[str, str]
    steps: List[GeneratedQuestStep]

    consequences_json: str         # Quest-level consequences JSON string
    prerequisites_json: str        # Quest-level prerequisites JSON string

    # Optional fields that AI might or might not provide
    guild_id: Optional[str] = None
    influence_level: Optional[str] = None # E.g., "local", "regional", "global"
    npc_involvement: Optional[Dict[str, str]] = None # E.g., {"quest_giver_id": "npc_001", "target_npc_id": "npc_002"}
    quest_giver_details_i18n: Optional[Dict[str, str]] = None
    consequences_summary_i18n: Optional[Dict[str, str]] = None

    _validate_json_strings = validator('consequences_json', 'prerequisites_json', pre=True, allow_reuse=True)(GeneratedQuestStep.ensure_valid_json_string)

    # Example of how you might load data if AI uses 'title_i18n' for quest name
    # This is more for data transformation before validation, Pydantic v2 has better ways for aliases.
    # For now, assume the loader handles this, or the AI is prompted for 'name_i18n'.
    # @validator('name_i18n', pre=True, always=True)
    # def populate_name_from_title(cls, v, values):
    #     if v is None and 'title_i18n' in values:
    #         return values['title_i18n']
    #     if v is None:
    #         raise ValueError("name_i18n or title_i18n must be provided")
    #     return v

# Example of how this might be used (for illustration, not part of the file itself normally)
# if __name__ == '__main__':
#     sample_step_data_valid = {
#         "title_i18n": {"en": "Explore the Cave"},
#         "description_i18n": {"en": "Find the hidden entrance."},
#         "required_mechanics_json": "{\"perception_check\": true, \"min_skill_level\": 5}",
#         "abstract_goal_json": "{\"goal_type\": \"discovery\", \"target\": \"cave_entrance\"}",
#         "step_order": 1,
#         "consequences_json": "{}",
#         "assignee_type": "player"
#     }
#     step = GeneratedQuestStep(**sample_step_data_valid)
#     print(f"Valid Step: {step.title_i18n['en']}")

#     sample_step_data_invalid_json = sample_step_data_valid.copy()
#     sample_step_data_invalid_json["required_mechanics_json"] = "{\"perception_check\": true, \"min_skill_level\": 5" # Invalid JSON
#     try:
#         GeneratedQuestStep(**sample_step_data_invalid_json)
#     except ValueError as e:
#         print(f"Caught expected error for invalid step JSON: {e}")

#     sample_quest_data_valid = {
#         "name_i18n": {"en": "The Great Hunt"},
#         "description_i18n": {"en": "Hunt the legendary beast."},
#         "steps": [sample_step_data_valid],
#         "consequences_json": "{\"reputation_change\": {\"faction_A\": -10}}",
#         "prerequisites_json": "{\"quests_completed\": [\"quest_001\"], \"min_level\": 10}",
#         "guild_id": "hunters_guild",
#         "influence_level": "regional"
#     }
#     quest = GeneratedQuest(**sample_quest_data_valid)
#     print(f"Valid Quest: {quest.name_i18n['en']}")
#     print(f"Quest guild_id: {quest.guild_id}")

#     # Example where AI might provide dicts for JSON fields
#     sample_step_data_dict_json = {
#         "title_i18n": {"en": "Negotiate Peace"},
#         "description_i18n": {"en": "Broker a truce between factions."},
#         "required_mechanics_json": {"dialogue_choice": "persuasion", "min_charisma": 7}, # Provided as dict
#         "abstract_goal_json": {"goal_type": "diplomacy", "target_factions": ["A", "B"]}, # Provided as dict
#         "step_order": 2,
#         "consequences_json": {} # Provided as dict
#     }
#     step_from_dict_json = GeneratedQuestStep(**sample_step_data_dict_json)
#     print(f"Step from dict JSON, required_mechanics_json: {step_from_dict_json.required_mechanics_json}") # Should be stringified
#     assert isinstance(step_from_dict_json.required_mechanics_json, str)
#     assert isinstance(step_from_dict_json.consequences_json, str)

#     sample_quest_data_invalid_json = sample_quest_data_valid.copy()
#     sample_quest_data_invalid_json["consequences_json"] = "{\"reputation_change\":,}" # Invalid JSON
#     try:
#         GeneratedQuest(**sample_quest_data_invalid_json)
#     except ValueError as e:
#         print(f"Caught expected error for invalid quest JSON: {e}")
