from pydantic import BaseModel, field_validator # Changed
from typing import List, Dict, Optional, Any
import json

class GeneratedQuestStep(BaseModel):
    """
    Pydantic model for a single quest step generated by AI.
    Corresponds to game.models.quest_step.QuestStep
    """
    title_i18n: Dict[str, str]
    description_i18n: Dict[str, str]
    required_mechanics_json: str  # JSON string for specific mechanics
    abstract_goal_json: str       # JSON string for abstract goals
    step_order: int
    consequences_json: str        # JSON string for step-specific consequences
    assignee_type: Optional[str] = None # e.g., 'player', 'party'
    assignee_id: Optional[str] = None   # player_id or party_id

    @field_validator('required_mechanics_json', 'abstract_goal_json', 'consequences_json', mode='before') # Changed
    def ensure_valid_json_string(cls, v: Any) -> str: # Changed value to v
        if isinstance(v, (dict, list)): # If AI provides actual dict/list # Changed value to v
            try:
                return json.dumps(v) # Changed value to v
            except (TypeError, OverflowError) as e:
                raise ValueError(f"Invalid object for JSON stringification: {e}")
        if not isinstance(v, str): # Changed value to v
            raise ValueError("JSON field must be a string.")
        try:
            json.loads(v) # Changed value to v
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON string: {e}")
        return v # Changed value to v

class GeneratedQuest(BaseModel):
    """
    Pydantic model for a complete quest structure generated by AI.
    Corresponds to game.models.quest.Quest
    """
    # Using name_i18n for consistency, AI might output as title_i18n.
    # The data loading mechanism should handle aliasing if needed.
    name_i18n: Dict[str, str]
    description_i18n: Dict[str, str]
    steps: List[GeneratedQuestStep]

    consequences_json: str         # Quest-level consequences JSON string
    prerequisites_json: str        # Quest-level prerequisites JSON string

    # Optional fields that AI might or might not provide
    guild_id: Optional[str] = None
    influence_level: Optional[str] = None # E.g., "local", "regional", "global"
    npc_involvement: Optional[Dict[str, str]] = None # E.g., {"quest_giver_id": "npc_001", "target_npc_id": "npc_002"}
    quest_giver_details_i18n: Optional[Dict[str, str]] = None
    consequences_summary_i18n: Optional[Dict[str, str]] = None

    _validate_json_strings = field_validator('consequences_json', 'prerequisites_json', mode='before')(GeneratedQuestStep.ensure_valid_json_string) # Changed

    # Example of how you might load data if AI uses 'title_i18n' for quest name
    # This is more for data transformation before validation, Pydantic v2 has better ways for aliases.
    # For now, assume the loader handles this, or the AI is prompted for 'name_i18n'.
    # @validator('name_i18n', pre=True, always=True)
    # def populate_name_from_title(cls, v, values):
    #     if v is None and 'title_i18n' in values:
    #         return values['title_i18n']
    #     if v is None:
    #         raise ValueError("name_i18n or title_i18n must be provided")
    #     return v

# Example of how this might be used (for illustration, not part of the file itself normally)
# if __name__ == '__main__':
#     sample_step_data_valid = {
#         "title_i18n": {"en": "Explore the Cave"},
#         "description_i18n": {"en": "Find the hidden entrance."},
#         "required_mechanics_json": "{\"perception_check\": true, \"min_skill_level\": 5}",
#         "abstract_goal_json": "{\"goal_type\": \"discovery\", \"target\": \"cave_entrance\"}",
#         "step_order": 1,
#         "consequences_json": "{}",
#         "assignee_type": "player"
#     }
#     step = GeneratedQuestStep(**sample_step_data_valid)
#     print(f"Valid Step: {step.title_i18n['en']}")

#     sample_step_data_invalid_json = sample_step_data_valid.copy()
#     sample_step_data_invalid_json["required_mechanics_json"] = "{\"perception_check\": true, \"min_skill_level\": 5" # Invalid JSON
#     try:
#         GeneratedQuestStep(**sample_step_data_invalid_json)
#     except ValueError as e:
#         print(f"Caught expected error for invalid step JSON: {e}")

#     sample_quest_data_valid = {
#         "name_i18n": {"en": "The Great Hunt"},
#         "description_i18n": {"en": "Hunt the legendary beast."},
#         "steps": [sample_step_data_valid],
#         "consequences_json": "{\"reputation_change\": {\"faction_A\": -10}}",
#         "prerequisites_json": "{\"quests_completed\": [\"quest_001\"], \"min_level\": 10}",
#         "guild_id": "hunters_guild",
#         "influence_level": "regional"
#     }
#     quest = GeneratedQuest(**sample_quest_data_valid)
#     print(f"Valid Quest: {quest.name_i18n['en']}")
#     print(f"Quest guild_id: {quest.guild_id}")

#     # Example where AI might provide dicts for JSON fields
#     sample_step_data_dict_json = {
#         "title_i18n": {"en": "Negotiate Peace"},
#         "description_i18n": {"en": "Broker a truce between factions."},
#         "required_mechanics_json": {"dialogue_choice": "persuasion", "min_charisma": 7}, # Provided as dict
#         "abstract_goal_json": {"goal_type": "diplomacy", "target_factions": ["A", "B"]}, # Provided as dict
#         "step_order": 2,
#         "consequences_json": {} # Provided as dict
#     }
#     step_from_dict_json = GeneratedQuestStep(**sample_step_data_dict_json)
#     print(f"Step from dict JSON, required_mechanics_json: {step_from_dict_json.required_mechanics_json}") # Should be stringified
#     assert isinstance(step_from_dict_json.required_mechanics_json, str)
#     assert isinstance(step_from_dict_json.consequences_json, str)

#     sample_quest_data_invalid_json = sample_quest_data_valid.copy()
#     sample_quest_data_invalid_json["consequences_json"] = "{\"reputation_change\":,}" # Invalid JSON
#     try:
#         GeneratedQuest(**sample_quest_data_invalid_json)
#     except ValueError as e:
#         print(f"Caught expected error for invalid quest JSON: {e}")


class GenerationContext(BaseModel):
    """
    Context for AI generation tasks, such as narrative generation for events.
    """
    event: Dict[str, Any] = {} # Or a more specific Pydantic model if event_data has a known structure
    guild_id: str
    lang: str
    primary_location_details: Optional[Dict[str, Any]] = None
    party_context: Optional[Dict[str, Any]] = None
    # Optional: Include other context fields that might be relevant for generation
    # player_id: Optional[str] = None
    # character_id: Optional[str] = None
    # location_id: Optional[str] = None # This would be the ID, primary_location_details is the fetched data
    # world_state: Optional[Dict[str, Any]] = None # Snapshot of relevant world state

class ValidationIssue(BaseModel):
    """
    Represents a single validation issue found in AI-generated data.
    """
    field: str
    issue_type: str
    message: str
    severity: str  # e.g., "error", "warning", "info"
    corrected_value: Optional[Any] = None

class ValidatedEntity(BaseModel):
    """
    Represents an entity (like an NPC, Quest, Item) that has undergone validation.
    """
    entity_id: Optional[str] = None
    entity_type: str
    data: Dict[str, Any]
    validation_status: str  # e.g., "success", "success_with_autocorrections", "requires_moderation", "error"
    issues: List[ValidationIssue] = []
    original_data: Optional[Dict[str, Any]] = None # If autocorrections were applied

class ParsedAiData(BaseModel):
    """
    Holds the outcome of parsing and validating AI-generated data.
    """
    overall_status: str  # e.g., "success", "partial_success", "error"
    entities: List[ValidatedEntity] = []
    global_errors: List[str] = [] # For errors not specific to one entity, or structural errors
    raw_ai_output: Optional[str] = None

class ValidationError(BaseModel):
    """
    Placeholder for a custom validation error.
    Currently, Pydantic's ValidationError is used directly in validation logic.
    This can be expanded if specific custom error structures are needed.
    """
    detail: Optional[str] = None
    # Example: error_code: Optional[int] = None
    # Example: affected_fields: Optional[List[str]] = None


# Models for AI-generated content structures

class GeneratedNpcInventoryItem(BaseModel):
    item_template_id: str
    quantity: int

class GeneratedNpcFactionAffiliation(BaseModel):
    faction_id: str
    rank_i18n: Dict[str, str]

class GeneratedNpcRelationship(BaseModel):
    target_entity_id: str
    relationship_type: str # E.g., "friendly", "hostile", "neutral", "allied", "rival"
    strength: Optional[int] = None # E.g., -100 to 100

class GeneratedNpcProfile(BaseModel):
    """
    Pydantic model for an NPC profile generated by AI.
    Aligns with the output structure from MultilingualPromptGenerator.generate_npc_profile_prompt.
    """
    template_id: str
    name_i18n: Dict[str, str]
    role_i18n: Dict[str, str]
    archetype: str
    backstory_i18n: Dict[str, str]
    personality_i18n: Dict[str, str]
    motivation_i18n: Dict[str, str]
    visual_description_i18n: Dict[str, str]
    dialogue_hints_i18n: Dict[str, str]

    stats: Dict[str, Union[int, float]] # Allow float for stats like health percentage if needed
    skills: Dict[str, Union[int, float]]

    abilities: Optional[List[str]] = None
    spells: Optional[List[str]] = None
    inventory: Optional[List[GeneratedNpcInventoryItem]] = None

    faction_affiliations: Optional[List[GeneratedNpcFactionAffiliation]] = None
    relationships: Optional[List[GeneratedNpcRelationship]] = None

    is_trader: Optional[bool] = None
    currency_gold: Optional[int] = None


class POIModel(BaseModel):
    """Point of Interest within a location."""
    poi_id: str
    name_i18n: Dict[str, str]
    description_i18n: Dict[str, str]
    contained_item_ids: Optional[List[str]] = None
    npc_ids: Optional[List[str]] = None

class ConnectionModel(BaseModel):
    """Connection from one location to another."""
    to_location_id: str
    path_description_i18n: Dict[str, str]
    travel_time_hours: Optional[int] = None

class GeneratedLocationContent(BaseModel):
    """
    Pydantic model for AI-generated location content.
    Aligns with MultilingualPromptGenerator.generate_location_description_prompt.
    """
    template_id: str
    name_i18n: Dict[str, str]
    atmospheric_description_i18n: Dict[str, str]
    points_of_interest: Optional[List[POIModel]] = None
    connections: Optional[List[ConnectionModel]] = None
    possible_events_i18n: Optional[List[Dict[str, str]]] = None # List of i18n dicts for event descriptions
    required_access_items_ids: Optional[List[str]] = None
